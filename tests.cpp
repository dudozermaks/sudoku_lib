#include "sudoku_lib.hpp"
#include <bits/chrono.h>
#include <chrono>

void assert_print(bool passed, std::string msg) {
	std::cout << msg << std::endl;
	if (passed) {
		// green color
		std::cout << "\033[32m"
							<< "Passes";
	} else {
		// red color
		std::cout << "\033[31m"
							<< "Fails";
	}
	// reset color + new line
	std::cout << "\033[0m\n";
}

bool test_puzzle(std::string puzzle_string){
	Sudoku::Puzzle puzzle;
	if (!puzzle.load(puzzle_string)){
		return false;
	}
	Sudoku::Solver solver{puzzle};
	Sudoku::Solver::Result solver_result = solver.solve();
	return solver_result.is_solved;
}

int main() {
	// Sudoku::Solver(Sudoku::Puzzle("901500046425090081860010020502000000019000460600000002196040253200060817000001694")).get_difficulty();
	// Sudoku::Solver(Sudoku::Puzzle("600802735702356940300407062100975024200183079079624003400560207067240300920738406")).get_difficulty(); // naked 3
	// Sudoku::Solver(Sudoku::Puzzle("128400700973001040456070010002010096860503071710064800091040320000100000007005104")).get_difficulty();
	// Sudoku::Solver(Sudoku::Puzzle("800000000003600000070090200050007000000045700000100030001000068008500010090000400")).get_difficulty(); // Hardest sudoku ever
	auto benchmark_start = std::chrono::high_resolution_clock::now();
	// std::cout.setstate(std::ios::failbit);
	test_puzzle("035000001100007049090065008529700000700000004000009752800420060350800007900000820"); // 4900
	test_puzzle("072000000001048000003007040040001003500090004800300070020700400000150900000000720"); // 5600
	test_puzzle("005403670006002400000100300070046003000000000600750020001008000003200900098504100"); // 5650
	test_puzzle("105070804028000310000080000309608501000000000206501407000090000093000740407060908");
	test_puzzle("002090060000040902000700405000000109930000074504000000409006000107080000080020700"); // 7950
	test_puzzle("040158060005000100000204000023000890700000005064000210000402000006000400080369050");
	test_puzzle("000006509000300070018000030009030004200060007600050800040000710050003000107800000");
	test_puzzle("000060010000010300100803004020600900009537400007002080900701006003040000080020000"); // 7400
	test_puzzle("089200001000100004000000780001030809000060000402070300015000000700003000900008610"); // 9150
	test_puzzle("302054000080009000900000506000000380100060002098000000204000001000100030000480705"); // 10700
	test_puzzle("624900000739100008815004000400009370300040006591003002900400200100296004248357169"); // naked 4
	test_puzzle("000001200008090006060003100012004000090000060000800590006100070700030600005400000"); // 10000
	test_puzzle("064300000100020070070001500500000080000463000040000007001800050030090002000005790"); // 10000
	test_puzzle("800004000020900000000701420001000309300010007506000800042506000000008090000300005"); // 8800
	test_puzzle("500040023700100000308007000150009000000050000000300087000900601000003008460010005"); // 8800
	test_puzzle("000006509000300070018000030009030004200060007600050800040000710050003000107800000"); // 9900
	test_puzzle("460700103000380000700000200800002500650090028002800006006000002000064000508007039"); // 6150
	test_puzzle("001000570706050003900630040025073090367080154080540230070062009600090702093000400");
	test_puzzle("104320070280000103300008209000500000009203400000006000403600002906000014020034507");
	test_puzzle("934060050006004923008900046800546007600010005500390062360401270470600500080000634");


	// std::cout.clear();
	auto benchmark_end = std::chrono::high_resolution_clock::now();
	std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(benchmark_end - benchmark_start).count() << std::endl;
}
